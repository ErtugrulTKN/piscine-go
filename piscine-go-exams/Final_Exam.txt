//////////////////////////////////////////////////////////////// displayfirstparam.go
package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	args := os.Args[1:]
	if len(args) > 0 {
		first := []rune(args[0])
		for _, char := range first {
			z01.PrintRune(char)
		}
		z01.PrintRune('\n')
	}
}

//////////////////////////////////////////////////////////////// displaylastparam.go    

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	args := os.Args[1:]
	if len(args) > 0 {
		last := []rune(args[len(args)-1])
		for _, char := range last {
			z01.PrintRune(char)
		}
		z01.PrintRune('\n')
	}
}

//////////////////////////////////////////////////////////////// displayz.g

package main

import (
	"github.com/01-edu/z01"
)

func main() {
	z01.PrintRune('z')
}

//////////////////////////////////////////////////////////////// displaya.go

package main 

import (
	"github.com/01-edu/z01"
)

func main() {
	z01.PrintRune('a')
}

//////////////////////////////////////////////////////////////// hello.go  

package main

import (
	"github.com/01-edu/z01"
)

func main() {
	lala:= "Hello World!"
	word := []rune(lala)

	for _, i := range word {
		z01.PrintRune(i)
	}
	z01.PrintRune('\n')
}

//////////////////////////////////////////////////////////////// onlya.go

package piscine

import (
	"github.com/01-edu/z01"
)

func main() {
	z01.PrintRune('a')
}

//////////////////////////////////////////////////////////////// onlyz.go

package piscine

import (
	"github.com/01-edu/z01"
)

func main() {
	z01.PrintRune('z')
}

//////////////////////////////////////////////////////////////// printdigits.go

package main

import (
	"github.com/01-edu/z01"
)

func main() {
	for i := '0'; i <= '9'; i++ {
		z01.PrintRune(i)
	}
	z01.PrintRune('\n')
}

//////////////////////////////////////////////////////////////// strlen.go

package piscine

func StrLen(s string) int {
	d := []rune(s)
	var n int
	for asd := range d {
		n = asd
	}
	return n + 1
}

//////////////////////////////////////////////////////////////// paramcount.go

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	if len(os.Args) > 1 {
		arguments := os.Args[1:]
		count := 0

		for i := range arguments {
			count++
			i += i
		}
		z01.PrintRune(rune('0' + count))
		z01.PrintRune('\n')
	} else {
		z01.PrintRune('0')
		z01.PrintRune('\n')
	}
}

//////////////////////////////////////////////////////////////// displayalpham.go

package main

import "github.com/01-edu/z01"

func main() {
	str1 := "ABCDEFGHIJKLMNOPQRTSUVWXYZ"
	str2 := "abcdefghijklmnopqrstuvwxyz"

	st1 := []rune(str1)
	st2 := []rune(str2)

	for i := 0; i <= 25; i++ {
		if i%2 != 0 {
			z01.PrintRune(st1[i])
			z01.PrintRune(10)
		} else {
			z01.PrintRune(st2[i])
			z01.PrintRune(10)
		}

	}

}

//////////////////////////////////////////////////////////////// displayalrevm.go

package main

import (
	"github.com/01-edu/z01"
)

func main() {

	list := "aBcDeFgHiJkLmNoPqRsTuVxXyZ"

	for i := range list {
		z01.PrintRune(rune(list[i]))
	}
	z01.PrintRune('\n')

}

//////////////////////////////////////////////////////////////// countdown.go

package piscine

import (
	"github.com/01-edu/z01"
)

func main() {
	for i := '9'; i>='0'; i--{
		z01.PrintRune(i)
	}
	z01.PrintRune('\n')
}


//////////////////////////////////////////////////////////////// nrune.go

package piscine

func NRune(s string, n int) rune {
	deger := []rune(s)
	if n <= 0 { 
		return 0
	}
	if n > len(deger) {
		return 0 
	}
	return deger[n-1]
}

//////////////////////////////////////////////////////////////// lastrune.go

package piscine

func LastRune(s string) rune {
	value := []rune(s)
	son := len(value)-1
	return value[son]
}

//////////////////////////////////////////////////////////////// printstr.go

package piscine

import (
	"github.com/01-edu/z01"
)

func PrintStr(s string) {
	for _, asd := range s {
		z01.PrintRune(asd)
	}
}

//////////////////////////////////////////////////////////////// strrev.go

package piscine

func StrRev(s string) string {
	asd := []rune(s)
	for i, j := 0, len(asd)-1; i < j; i, j = i+1, j-1 {
		asd[i], asd[j] = asd[j], asd[i]
	}
	return string(asd)
}

//////////////////////////////////////////////////////////////// firstrune.go

package piscine

func FirstRune(s string) rune {
	d := []rune(s)
	return d[0]
}

//////////////////////////////////////////////////////////////// printreversealphabet.go

package main

import (
	"github.com/01-edu/z01"
)

func main() {
	for i := 'z'; i >= 'a'; i-- { 
		z01.PrintRune(i)
	}
	z01.PrintRune('\n')
}

//////////////////////////////////////////////////////////////// printalphabet.go  
 
package main

import (
	"github.com/01-edu/z01"
)

func main() {
	for i := 'A'; i <= 'Z'; i++ { 
		z01.PrintRune(i)
	}
	z01.PrintRune('\n')
}

//////////////////////////////////////////////////////////////// wdmatch.go

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func ok(s1 string, s2 string) bool {
	runes1 := []rune(s1)
	runes2 := []rune(s2)
	var rest string
	count := 0
	for i := 0; i < len(runes1); i++ {
		for j := count; j < len(runes2); j++ {
			if runes1[i] == runes2[j] {
				rest += string(runes1[i])
				j = len(runes2) - 1
			}
			count++
		}
	}
	return s1 == rest
}

func main() {
	if len(os.Args) == 3 {
		if ok(os.Args[1], os.Args[2]) {
			for _, rng := range os.Args[1] {
				z01.PrintRune(rng)
			}
			z01.PrintRune('\n')
		}
	}

}

//////////////////////////////////////////////////////////////// ispowerof2.go

package main

import (
	"os"
	"strconv"

	"github.com/01-edu/z01"
)

func ispowerof2(n int) string {
	var i = 2
	if n == 1 || n == 2 {
		return "true"
	}

	for {
		if i == n {
			return "true"
		}

		if i > n {
			return "false"
		}

		i *= 2
	}
}

func main() {

	args := os.Args
	var otsi int

	args = os.Args

	if len(args) == 2 {
		otsi, _ = strconv.Atoi(args[1])
		ans := ispowerof2(otsi)
		for _, x := range ans {
			z01.PrintRune(x)
		}
		z01.PrintRune('\n')
	} else {
	}
}
//-----------------------------------------------------------------

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func StringToInt(str string) int {
	n := 0
	for _, r := range str {
		n = n*10 + int(r-'0')
	}
	return n
}

func IntToString(n int) string {
	str := ""
	for n != 0 {
		str = string(n%10+'0') + str
		n /= 10
	}
	return str
}

func ispowerof2(x int) bool {
	if x <= 1 {
		return false
	}
	for x > 1 {
		if x%2 != 0 {
			return false
		}
		x /= 2
	}
	return true
}

func main() {
	if len(os.Args) == 2 {
		n := ispowerof2(StringToInt(os.Args[1]))
		if n {
			z01.PrintRune('t')
			z01.PrintRune('r')
			z01.PrintRune('u')
			z01.PrintRune('e')
			z01.PrintRune('\n')
		} else {
			z01.PrintRune('f')
			z01.PrintRune('a')
			z01.PrintRune('l')
			z01.PrintRune('s')
			z01.PrintRune('e')
			z01.PrintRune('\n')
		}
	} else {
		z01.PrintRune('\n')
		return
	}
}

//////////////////////////////////////////////////////////////// rot13.go 

package piscine

func rot13(s string) string {
	karakterler := []rune(s)
	str := ""
	for _, i := range karakterler {
		if i >= 'a' && i <= 'z' {
			str += string((i-'a'+13)%26 + 'a')
		} else if i >= 'A' && i <= 'Z' {
			str += string((i-'A'+13)%26 + 'A')
		} else {
			str += string(i)
		}
	}
	return str
}


//////////////////////////////////////////////////////////////// lastword.go

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	if len(os.Args) != 2 {
		return
	}

	input := os.Args[1]
	lastWord := ""
	inWord := false

	for i := len(input) - 1; i >= 0; i-- {
		if input[i] != ' ' {
			inWord = true
			lastWord = string(input[i]) + lastWord
		} else if inWord {
			break
		}
	}

	for _, ch := range lastWord {
		z01.PrintRune(ch)
	}

	if lastWord == "" {
		return
	}
	z01.PrintRune('\n')
}

//////////////////////////////////////////////////////////////// rot14.go

package piscine

func Rot14(s string) string {
	karakterler := []rune(s)
	str := ""
	for _, i := range karakterler {
		if i >= 'a' && i <= 'z' {
			str += string((i-'a'+14)%26 + 'a')
		} else if i >= 'A' && i <= 'Z' {
			str += string((i-'A'+14)%26 + 'A')
		} else {
			str += string(i)
		}
	}
	return str
}

//////////////////////////////////////////////////////////////// max.go

package piscine

func Max(a []int) int {
	if len(a) == 0 {
		return 0
	}
	myMaximum := a[0]
	for _, value := range a {
		if value > myMaximum {
			myMaximum = value
		}
	}
	return myMaximum
}

//////////////////////////////////////////////////////////////// reduceint.go

package piscine

import "github.com/01-edu/z01"

func ReduceInt(a []int, f func(int, int) int) {  
	acc := a[0]
	for i := 1; i < len(a); i++ {
		acc = f(acc, a[i])
	}
	z01.PrintRune(acc)
}

//////////////////////////////////////////////////////////////// switchcase.go

package main

import (
	"fmt"
	"os"
	"unicode"
)

func main() {
	if len(os.Args) == 2 {
		runes := []rune(os.Args[1])
		for i, r := range runes {
			if unicode.IsLower(r) {                                                    
				runes[i] = unicode.ToUpper(r)
			} else if unicode.IsUpper(r) {
				runes[i] = unicode.ToLower(r)
			}
		}
		fmt.Println(string(runes))
	}
}
//-----------------------------------------------------------------------

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	argumanlar := os.Args[1:]
	if len(argumanlar) == 1 {
		harfler := []rune(argumanlar[0])
		for _, i := range harfler {
			if i >= 'A' && i <= 'Z' {
				i = rune(i + 32)
			} else if i >= 'a' && i <= 'z' {
				i = rune(i - 32)
			}
			z01.PrintRune(i)
		}
	}
}

//////////////////////////////////////////////////////////////// swap.go

package piscine

func Swap(a *int, b *int) {
	c := *a
	*a = *b
	*b = c

}
//////////////////////////////////////////////////////////////// compare.go	

package piscine

func Compare(a, b string) int {
	if a == b {
		return 0
	}

	if a > b {
		return 1
	}

	if a < b {
		return -1
	}
	return 0

}

//////////////////////////////////////////////////////////////// expandstr.go

package main

import "os"

func main() {
	Expandstr()
}

func Expandstr() {
	if len(os.Args) != 2 {
		return
	}
	answer := ""
	isWord := false
	flag := 0
	for _, letter := range os.Args[1] {
		if isValid(letter) {
			isWord = true
			flag = 1
		} else if letter == ' ' {
			isWord = false
			if flag == 1 {
				answer += "   "
				flag = 0
			}
		}
		if isWord {
			answer += string(letter)
		}
	}
	if answer[len(answer)-1] == ' ' {
		answer = answer[:len(answer)-3]
	}
	os.Stdout.WriteString(answer + "\n")
}

func isValid(v rune) bool {
	if (v >= 'A' && v <= 'Z') || (v >= 'a' && v <= 'z') || (v >= '0' && v <= '9') {
		return true
	}
	return false
}

//////////////////////////////////////////////////////////////// tabmult.go	

package main

import (
	"os"

	"github.com/01-edu/z01"

	"strconv"
)

func main() {
	arg := os.Args[1:]
	if len(arg) != 1 {
		z01.PrintRune(10)
	} else {
		intn, err := strconv.Atoi(arg[0])
		if err == nil {
			if intn < 0 {
				z01.PrintRune(10)
				return
			}
			for i := 1; i < 10; i++ {
				bruh(i)
				z01.PrintRune(' ')
				z01.PrintRune('x')
				z01.PrintRune(' ')
				bruh(intn)
				z01.PrintRune(' ')
				z01.PrintRune('=')
				z01.PrintRune(' ')
				bruh(i * intn)
				z01.PrintRune(10)
			}
		}
	}
}

func bruh(lol int) {
	if lol >= 10 {
		bruh(lol / 10)
	}
	z01.PrintRune(rune(lol%10 + 48))
}

//--------------------------------------------------------------------------------//

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	argumanlar := os.Args[1:]
	if len(argumanlar) == 1 {
		sayi := Atoi(argumanlar[0])
		for i := 1; i < 10; i++ {
			harf := rune(i + '0')
			z01.PrintRune(harf)
			z01.PrintRune(' ')
			z01.PrintRune('x')
			z01.PrintRune(' ')
			for _, a := range argumanlar[0] {
				z01.PrintRune(a)
			}
			z01.PrintRune(' ')
			z01.PrintRune('=')
			z01.PrintRune(' ')
			result := sayi * i
			var dizi []int
			for result > 0 {
				dizi = append(dizi, result%10)
				result = result / 10
			}
			for i := len(dizi) - 1; i >= 0; i-- {
				basamak := rune(dizi[i] + '0')
				z01.PrintRune(basamak)
			}
			z01.PrintRune('\n')
		}
	}
}
func Atoi(s string) int {
	result := 0
	for _, i := range s {
		result = result*10 + int(i-'0')
	}
	return result
}

//////////////////////////////////////////////////////////////// searchreplace.go

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	if len(os.Args) == 4 {
		for _, v := range os.Args[1] {
			if v == []rune(os.Args[2])[0] {
				v = []rune(os.Args[3])[0]
			}
			z01.PrintRune(v)
		}
		z01.PrintRune('\n')
	}
}

//////////////////////////////////////////////////////////////// alphamirror.go

package main

import (
	"github.com/01-edu/z01"
	"os"
)

func main() {
	if len(os.Args) == 2 {
		arg := []rune(os.Args[1])
		for i, ch := range arg {
			if ch >= 'a' && ch <= 'z' {
				arg[i] = 'z' - ch + 'a'
			} else if ch >= 'A' && ch <= 'Z' {
				arg[i] = 'Z' - ch + 'A'
			}
		}
		z01.PrintRune(string(arg))
	}

	z01.PrintRune('\n')
}

//////////////////////////////////////////////////////////////// doop.go

package main

import (
	"os"
)

func main() {
	if len(os.Args) == 4 {
		args := os.Args[1:]
		var firstNum int
		var secondNum int
		var operator string
		IsfirstNum := false
		IsSecondNum := false
		if string(args[0][0]) == "-" {
			firstNum, IsfirstNum = findNumber(args[0][1:], args[0])
		} else if string(args[0][0]) != "-" {
			firstNum, IsfirstNum = findNumber(args[0], args[0])
		}
		if string(args[2][0]) != "-" {
			secondNum, IsSecondNum = findNumber(string(args[2]), string(args[2]))
		} else if string(args[2][0]) == "-" {
			secondNum, IsSecondNum = findNumber(args[2][1:], args[2])
		}
		if IsOperator(args[1]) && overFlow(firstNum) && overFlow(secondNum) {
			operator = args[1]
			if IsSecondNum && IsfirstNum {
				switch operator {
				case "+":
					os.Stdout.Write(intToByte(firstNum + secondNum))
				case "-":
					os.Stdout.Write(intToByte(firstNum - secondNum))
				case "*":
					os.Stdout.Write(intToByte(firstNum * secondNum))
				case "/":
					if secondNum == 0 {
						strToByte("No division by 0\n")
					} else {
						os.Stdout.Write(intToByte(firstNum / secondNum))
					}
				case "%":
					if secondNum == 0 {
						strToByte("No modulo by 0\n")
					} else {
						os.Stdout.Write(intToByte(firstNum % secondNum))
					}
				}
			}
		}
	}
}

func intToByte(num int) []byte {
	var lists []byte
	negNum := false
	if num == 0 {
		lists = append(lists, 48)
		lists = append(lists, "\n"[0])
		return lists
	}
	if num < 0 {
		negNum = true
		num = num * -1
	}
	for 0 < num {
		lists = append([]byte{byte(num%10 + 48)}, lists...)
		num = num / 10
	}
	if negNum {
		lists = append([]byte{byte(45)}, lists...)
	}
	lists = append(lists, "\n"[0])
	return lists
}

func strToByte(s string) {
	var lists []byte
	for i := range s {
		lists = append(lists, s[i])
	}
	os.Stdout.Write(lists)
}

func findNumber(s string, s2 string) (int, bool) {
	if IsNumeric(s) {
		return Atoi(s2), true
	}
	return 0, false
}

func overFlow(num int) bool {
	if num < 9223372036854775807 && -9223372036854775807 < num {
		return true
	}
	return false
}

func IsOperator(s string) bool {
	if s == "+" || s == "-" || s == "/" || s == "%" || s == "*" {
		return true
	}
	return false
}

func IsNumeric(s string) bool {
	for _, symbol := range s {
		if symbol >= 48 && symbol <= 57 {
			continue
		} else {
			return false
		}
	}
	return true
}

func Atoi(s string) int {
	newInt := 0
	var number int
	plussorminus := 1
	for posnum, symbol := range s {
		if posnum == 0 && symbol == 43 {
			continue
		} else if posnum == 0 && symbol == 45 {
			plussorminus = -1
		} else if symbol >= 48 && symbol <= 57 {
			for i := '0'; symbol > i; i++ {
				number++
			}
			newInt = (newInt * 10) + number
			number = 0
		} else {
			return 0
		}
	}
	return newInt * plussorminus
}

//---------------------------------------------------------------------------------------------------

package main

import (
	"os"
)

func StringToInt(str string) (int, string) {
	n := 0
	sign := 1
	for _, r := range str {
		if r == '-' {
			sign = -1
		} else {
			if r < '0' || r > '9' {
				return 0, "Hata"
			}
			n = n*10 + int(r-'0')
		}
	}
	return n * sign, "0"
}

func IntToString(n int) string {
	sign := ""
	str := ""
	for i := 0; ; i++ {
		if n < 0 {
			sign = "-"
			n *= -1
		}
		str = string(n%10+'0') + str
		n /= 10
		if n == 0 {
			return sign + str
		}
	}
}

func main() {
	arg := os.Args[1:]
	if len(arg) < 1 {
		return
	}
	int1, err1 := StringToInt(arg[0])
	opt := arg[1]
	int2, err2 := StringToInt(arg[2])
	if err1 != "0" || err2 != "0" {
		print("0")
		return
	}
	value := 0
	if opt == "+" {
		value = int1 + int2
	} else if opt == "-" {
		value = int1 - int2
	} else if opt == "*" {
		value = int1 * int2
	} else if opt == "/" {
		if int2 == 0 {
			print("No division by 0")
			return
		}
		value = int1 / int2
	} else if opt == "%" {
		if int2 == 0 {
			print("No Modulo  by 0")
			return
		}
		value = int1 % int2
	}
	print(IntToString(value))
}

func print(msg string) {
	_, err := os.Stdout.WriteString(msg)
	if err != nil {
		panic(err)
	}
	_, err1 := os.Stdout.WriteString("\n")
	if err1 != nil {
		panic(err1)
	}
}

//////////////////////////////////////////////////////////////// findprevprime.go

package piscine

import "github.com/01-edu/z01"

func FindPrevPrime(nb int) int {
	if nb < 2 {
		return 0
	}
	if is.Prime(nb) {                     
		return nb
	}
	return FindPrevPrime(nb - 1)
}

//////////////////////////////////////////////////////////////// reversebits.go	

package main

import (
	"fmt"
	"os"
	"strconv"
)

func reverseBits(octe byte) byte {
	var reversed byte
	for i := 0; i < 8; i++ {
		reversed <<= 1
		reversed |= octe & 1
		octe >>= 1
	}
	return reversed
}
func main() {
	if len(os.Args) == 2 {
		nbr, _ := strconv.Atoi(os.Args[1])
		octe := byte(nbr)
		reversed := reverseBits(octe)
		fmt.Printf("Reversed: %08b\n", reversed)
	}
}
//////////////////////////////////////////////////////////////// chunk.go

package piscine

import "github.com/01-edu/z01"

func Chunk(a []int, ch int) {
	var slice []int
	if ch <= 0 {
		z01.PrintRune('\n')
		return
	}
	result := make([][]int, 0, len(a)/ch+1)
	for len(a) >= ch {
		slice, a = a[:ch], a[ch:]             
		result = append(result, slice)
	}
	if len(a) > 0 {
		result = append(result, a[:])
	}
	z01.PrintRune(result)
}

//////////////////////////////////////////////////////////////// foldint.go

package piscine

import "github.com/01-edu/z01"

func FoldInt(f func(int, int) int, a []int, n int) {
	result := n
	for _, v := range a {
		result = f(result, v)
	}
	z01.PrintRune(result)
}

//////////////////////////////////////////////////////////////// swapbits.go

package piscine 

func SwapBits(octet byte) byte {
	a := octet * 16
	b := octet / 16
	return a + b
}

//////////////////////////////////////////////////////////////// capitalize.go

package piscine

func prim(a rune) bool {
	if (a >= 'A' && a <= 'Z')(a >= 'a' && a <= 'z')(a >= '0' && a <= '9') {
		return true
	}
	return false
}

func Capitalize(s string) string {
	ar := []rune(s)
	letra := true
	for i := 0; i < len(s); i++ {
		if prim(ar[i]) == true && letra {
			if ar[i] >= 'a' && ar[i] <= 'z' {
				ar[i] = 'A' - 'a' + ar[i]
			}
			letra = false
		} else if ar[i] >= 'A' && ar[i] <= 'Z' {
			ar[i] = 'a' - 'A' + ar[i]
		} else if prim(ar[i]) == false {
			letra = true
		}
	}
	return string(ar)
}

//////////////////////////////////////////////////////////////// repeatalpha.go

package main

import (
	"fmt"
	"os"
	"unicode"
)

func main() {
	if len(os.Args) == 2 {
		for _, r := range os.Args[1] {
			fmt.Printf("%c", r)
			if unicode.IsLetter(r) {
				rep := unicode.ToLower(r) - 'a'                                 
				for i := 0; i < int(rep); i++ {
					fmt.Printf("%c", r)
				}
			}
		}
		fmt.Println()
	}
}

//----------------------------------------------------------------------------

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func repeatAlpha(s string) string {
	var result string
	for _, char := range s {
		if (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') {
			index := int(char) - int('a')
			if char >= 'A' && char <= 'Z' {
				index = int(char) - int('A')
			}
			for i := 0; i <= index; i++ {
				result += string(char)
			}
		} else {
			result += string(char)
		}
	}
	return result
}

func main() {
	if len(os.Args) != 2 {
		z01.PrintRune('\n')
		return
	}
	input := os.Args[1]
	output := repeatAlpha(input)
	for _, char := range output {
		z01.PrintRune(char)
	}
	z01.PrintRune('\n')
}

//////////////////////////////////////////////////////////////// atoi.go

package piscine

func Atoi(s string) int {
	var res int
	bang := "posi"
	if s == "" {
		res = 0
	} else {
		if s[0] == '-' {
			bang = "nega"
			s = s[1:]
		} else if s[0] == '+' {
			s = s[1:]
		}
		if len(s) > 0 {
			for i := range s {
				if s[i] < 48 || s[i] > 57 {
					res = 0
					break
				}
				res = res*10 + int(s[i]-'0')
			}
			if bang == "nega" {
				res *= -1
			}

		}

	}
	return res
}

//////////////////////////////////////////////////////////////// reversestrcap.go

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func Capitalize(s string) string {
	a := 0
	array := []rune(s)
	for range s {
		a++
	}
	for i := 0; i < a; i++ {
		if array[i] >= 'A' && array[i] <= 'Z' {
			array[i] = array[i] + 32
		}
		if array[0] >= 'a' && array[0] <= 'z' {
			array[0] = array[0] - 32
		}
		if i > 0 {
			if array[i-1] > 'Z' && array[i-1] < 'a' || array[i-1] < 'A' && array[i-1] > '9' || array[i-1] < '0' && array[i-1] != '\'' || array[i-1] > 'z' {
				if array[i] >= 'a' && array[i] <= 'z' {
					array[i] = array[i] - 32
				}
			}
		}
	}
	return string(array)
}

func main() {
	arguments := os.Args[1:]
	if len(arguments) < 1 {
		return
	}
	for _, str := range arguments {
		var revresedString []byte
		for i := range str {
			revresedString = append(revresedString, str[len(str)-1-i])
		}
		capString := Capitalize(string(revresedString))
		for i := len(capString) - 1; i >= 0; i-- {
			z01.PrintRune(rune(capString[i]))
		}
		z01.PrintRune('\n')
	}
}

//////////////////////////////////////////////////////////////// printbits.go

package main

import (
	"fmt"
	"os"
	"strconv"
)

func main() {
	if len(os.Args) == 2 {
		nbr, _ := strconv.Atoi(os.Args[1])
		printBits(byte(nbr))
	}
}

func printBits(octe byte) {
	fmt.Printf("%08b", octe)
}

//////////////////////////////////////////////////////////////// inter.go

package main

import (
	"fmt"
	"os"
	"strings"
)

func result(s1 string, s2 string) string {
	var rest []rune
	for _, a := range s1 {
		for _, b := range s2 {
			if a == b && !strings.ContainsRune(string(rest), a) {      
				rest = append(rest, a)
			}
		}
	}
	return string(rest)
}

func main() {
	if len(os.Args) == 3 {
		fmt.Println(result(os.Args[1], os.Args[2]))
	}
}

//////////////////////////////////////////////////////////////// union.go

package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {
	if len(os.Args) == 3 {
		var res string
		s1 := os.Args[1]
		s2 := os.Args[2]

		for _, v := range s1 {
			if !strings.ContainsRune(res, v) {         
				res += string(v)
			}
		}
		for _, v := range s2 {
			if !strings.ContainsRune(res, v) {
				res += string(v)
			}
		}
		fmt.Print(res)
	}
	fmt.Println()
}

//////////////////////////////////////////////////////////////// piglatin.go

package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {
	if len(os.Args) != 2 || os.Args[1] == "" {
		return
	}
	s := os.Args[1]                                  
	vowel := strings.IndexAny(s, "aeiouAEIOU")
	if vowel == -1 {
		fmt.Println("No vowels")
	} else {
		fmt.Println(string(s[vowel:]) + string(s[:vowel]) + "ay")
	}
}

//////////////////////////////////////////////////////////////// romannumbers.go	

package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

type roman struct {
	num        int
	romanDigit string
}

func main() {
	if len(os.Args) == 2 {
		nbr, err := strconv.Atoi(os.Args[1])
		if err != nil || nbr >= 4000 || nbr == 0 {
			fmt.Println("ERROR: cannot convert to roman digit")
			return
		}
		patter := []roman{
			{num: 1000, romanDigit: "M"},
			{num: 900, romanDigit: "CM"},
			{num: 500, romanDigit: "D"},
			{num: 400, romanDigit: "CD"},
			{num: 100, romanDigit: "C"},
			{num: 90, romanDigit: "XC"},
			{num: 50, romanDigit: "L"},     
			{num: 40, romanDigit: "XL"},
			{num: 10, romanDigit: "X"},
			{num: 9, romanDigit: "IX"},
			{num: 5, romanDigit: "V"},
			{num: 4, romanDigit: "IV"},
			{num: 1, romanDigit: "I"},
		}
		sumRoman, romandigit := print(nbr, patter)
		fmt.Println(strings.TrimSuffix(sumRoman, "+"))
		fmt.Println(romandigit)
	}
}

func print(nbr int, patter []roman) (string, string) {
	var sumRomanDigit, result string
	for _, v := range patter {
		for nbr >= v.num {
			sumRomanDigit += v.romanDigit + "+"
			result += v.romanDigit
			nbr -= v.num
		}
	}
	sumRomanDigit = formatsum(sumRomanDigit, patter)
	return sumRomanDigit, result
}

func formatsum(a string, patter []roman) string {
	result2 := strings.Split(a, "+")

	for i, v := range result2 {
		if len(v) == 2 {
			result2[i] = fmt.Sprintf("(%s-%s)", string(result2[i][1]), string(result2[i][0]))
		}
	}
	a = strings.Join(result2, "+")
	return a
}

//////////////////////////////////////////////////////////////// firstword.go

package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {
	if len(os.Args) == 2 {
		s := strings.Split(strings.TrimSpace(os.Args[1]), " ")[0]
		if s != "" {
			fmt.Println(s)
		}
	}
}

//-----------------------------------------------------------------------------

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	if len(os.Args) == 2 {
		str := os.Args[1]
		result := ""
		for _, r := range str {
			if r != ' ' {
				result += string(r)
			} else {
				break
			}
		}
		for _, r := range result {
			z01.PrintRune(r)
		}
		z01.PrintRune('\n')
	} else {
		z01.PrintRune('\n')
		return
	}
}

//////////////////////////////////////////////////////////////// sortwordarr.go			 

package piscine

func SortWordArr(array []string) {
	ech:=""
	for i:=0;i<len(array);i++{
		for j:=i+1;j<len(array);j++{
			a:=[]byte(array[j])
			b:=[]byte(array[i])
			if comparearrayascii(a, b){
				ech=array[i]
				array[i]=array[j]
				array[j]=ech
			}
		}
	}
}

func comparearrayascii(a, b []byte)bool{
	n:=0
	if len(a)<=len(b){
		n=len(a)	
	}else{
		n=len(b)
	}
	for i:=0;i<n;i++{
		if b[i]<a[i]{
			return false
		}
	}
	return true
}

//////////////////////////////////////////////////////////////// cleanstr.go 

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	answerSlice := []string{}
	var appendString string
	if len(os.Args) == 1 || len(os.Args) > 2 {
		z01.PrintRune('\n')
	} else {
		inputSlice := []rune(os.Args[1])
		for i := 0; i <= len(inputSlice); i++ {
			if i == len(inputSlice) {
				answerSlice = append(answerSlice, appendString)
				break
			}
			if inputSlice[i] != 32 && inputSlice[i] != 9 && inputSlice[i] != 10 {
				appendString += string(inputSlice[i])
			}
			if (len(appendString) != 0) && (inputSlice[i] == 32 || inputSlice[i] == 9 || inputSlice[i] == 10) {
				answerSlice = append(answerSlice, appendString)
				appendString = ""
			}
		}
		for a := 0; a < len(answerSlice); a++ {
			printString := answerSlice[a]
			printSlice := []rune(printString)
			for j := 0; j < len(printSlice); j++ {
				z01.PrintRune(printSlice[j])
			}
			if a < len(answerSlice)-1 && answerSlice[a] != "harder" {
				z01.PrintRune(32)
			}
		}
		z01.PrintRune('\n')
	}
}

//////////////////////////////////////////////////////////////// addprimesum.go

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func IsPrime(nb int) bool {
	result := true

	if nb <= 1 {
		result = false
	}
	for i := 2; i < nb; i++ {
		if nb%i == 0 {
			result = false
			break
		}
	}
	return result
}

func Atoi(s string) int {
	symbol := 0
	isNeg := false
	slice := []rune(s)

	if len(s) == 0 {
		return 0
	}

	if slice[0] == '-' {
		slice = slice[1:]
		isNeg = true
	} else if slice[0] == '+' {
		slice = slice[1:]
	}
	for i := 0; i < len(slice); i++ {
		if slice[i] < '0' || slice[i] > '9' {
			return 0
		}
	}
	for _, inp := range slice {
		symbol = (symbol * 10) + int(inp-'0')
	}
	if isNeg {
		symbol = symbol * (-1)
	}
	return symbol
}
func PrintNbr(n int) {
	t := 1
	if n < 0 {
		t = -1
		z01.PrintRune('-')
	}
	if n != 0 {
		f := (n / 10) * t
		if f != 0 {
			PrintNbr(f)
		}
		k := (n % 10 * t) + '0'
		z01.PrintRune(rune(k))
	} else {
		z01.PrintRune('0')
	}
}

func main() {
	if len(os.Args) != 2 {
		z01.PrintRune('0')
		z01.PrintRune('\n')
	} else {
		argument := Atoi(os.Args[1])

		if argument < 0 {
			z01.PrintRune('0')
			z01.PrintRune('\n')
		} else {
			result := 0
			for ; argument >= 0; argument-- {
				if IsPrime(argument) {
					result += argument
				}
			}
			PrintNbr(result)
			z01.PrintRune('\n')
		}
	}
}

//////////////////////////////////////////////////////////////// printhex.go

package main

import (
	"os"
	"strconv"

	"github.com/01-edu/z01"
)

func main() {
	ar := os.Args
	errStr := "ERROR"
	if len(ar) == 2 {
		n, er := strconv.Atoi(ar[1])
		if er != nil {
			for _, v := range errStr {
				z01.PrintRune(v)
			}
		}
		for _, r := range hex(n) {
			z01.PrintRune(r)
		}
		z01.PrintRune('\n')
	}
}

func hex(n int) string {
	base := "0123456789abcdef"
	if n < 16 {
		return string(base[n])
	}
	return hex(n/16) + string(base[n%16])
}
//--------------------------------------------------------------------

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func StringToInt(str string) int {
	n := 0
	for _, r := range str {
		if r < '0' || r > '9' {
			return 0
		}
		n = n*10 + int(r-'0')
	}
	return n
}

func IntToString(n int) string {
	str := ""
	for n != 0 {
		str = string(n%10+'0') + str
		n /= 10
	}
	return str
}

func main() {
	if len(os.Args) == 2 {
		x := StringToInt(os.Args[1])
		n := []int{}
		if x == 0 {
			z01.PrintRune('0')
			z01.PrintRune('\n')
			return
		}
		for x != 0 {
			n = append(n, x%16)
			x /= 16
		}
		for i := 0; i < len(n)/2; i++ {
			n[i], n[len(n)-1-i] = n[len(n)-1-i], n[i]
		}
		for _, r := range n {
			for _, i := range IntToString(r) {
				if IntToString(r) == "10" {
					z01.PrintRune('a')
					break
				} else if IntToString(r) == "11" {
					z01.PrintRune('b')
					break
				} else if IntToString(r) == "12" {
					z01.PrintRune('c')
					break
				} else if IntToString(r) == "13" {
					z01.PrintRune('d')
					break
				} else if IntToString(r) == "14" {
					z01.PrintRune('e')
					break
				} else if IntToString(r) == "15" {
					z01.PrintRune('f')
					break
				} else {
					z01.PrintRune(i)
					break
				}
			}

		}
		z01.PrintRune('\n')
	} else {
		z01.PrintRune('\n')
		return
	}
}

//////////////////////////////////////////////////////////////// gcd.go

package main

import (
	"fmt"
	"os"
	"strconv"
)

func main() {
	arg := os.Args[1:]
	if len(arg) != 2 {
		return
	}
	bruh1, _ := strconv.Atoi(arg[0])
	bruh2, _ := strconv.Atoi(arg[1])

	result := gcd(bruh1, bruh2)
	fmt.Print(result)
	fmt.Println()

}
func gcd(bruh1, bruh2 int) int {
	for bruh2 != 0 {
		bruh1, bruh2 = bruh2, bruh1%bruh2
	}
	return bruh1
}

//---------------------------------------------------------------

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func StringToInt(str string) int {
	n := 0
	for _, r := range str {
		n = n*10 + int(r-'0')
	}
	return n
}

func IntToSring(n int) string {
	str := ""
	for n != 0 {
		str = string(n%10+'0') + str
		n /= 10
	}
	return str
}

func gcd(x, y int) int {
	n := 0
	r := 0
	if x > y {
		n = y
	} else {
		n = x
	}
	for i := 1; i <= n; i++ {
		if x%i == 0 && y%i == 0 {
			r = i
		}
	}
	return r
}

func main() {
	if len(os.Args) == 3 {
		x := StringToInt(os.Args[1])
		y := StringToInt(os.Args[2])
		str := gcd(x, y)
		for _, r := range IntToSring(str) {
			z01.PrintRune(r)
		}
		z01.PrintRune('\n')
	} else {
		z01.PrintRune('\n')
		return
	}
}

//////////////////////////////////////////////////////////////// printcomb.go

package piscine
import (
	"github.com/01-edu/z01"
)
func PrintComb() {
	for a := '0'; a <= '9'; a++ {
		for b := a + 1; b <= '9'; b++ {
			for c := b + 1; c <= '9'; c++ {
				z01.PrintRune(a)
				z01.PrintRune(b)
				z01.PrintRune(c)
				if a < '7' || b < '8' || c < '9' {
					z01.PrintRune(',')
					z01.PrintRune(' ')
				}
			}
		}
	}
	z01.PrintRune('\n')
}


//////////////////////////////////////////////////////////////// split.go

package piscine

// import "fmt"

func Split(str, charset string) []string {
	char_len := get_length(charset)
	str_len := get_length(str)
	// runes := []rune(str)
	size := 0
	for ind := 0; ind <= str_len-char_len; ind++ {
		if string(str[ind:ind+char_len]) == charset {
			size++
		}
	}
	// fmt.Println(size)
	resArr := make([]string, size+1)
	i := 0
	start := 0
	ind := 0
	for ; ind <= str_len-char_len; ind++ {
		// fmt.Println(str_len, "/", ind, "+", char_len, string(runes[ind:ind+char_len]))
		if string(str[ind:ind+char_len]) == charset {
			resArr[i] = string(str[start:ind])
			i++
			start = ind + char_len
		}
		if ind == str_len-char_len {
			// ind += char_len
			resArr[i] = string(str[start:])
		}
	}
	// resArr[i] = string(str[start:ind])
	return resArr
}

//////////////////////////////////////////////////////////////// hiddenp.go

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {

	str1 := os.Args[1]
	str2 := os.Args[2]

	var match string
	count := 0

	if len(os.Args) == 3 {
		for i := 0; i < len(str1); i++ {
			for j := count; j < len(str2); j++ {
				if str1[i] == str2[j] {
					match += string(str1[i])
					count = j + 1
					break
				}
			}
		}
		if match == str1 {
			z01.PrintRune('1')
			z01.PrintRune('\n')
		} else {
			z01.PrintRune('0')
			z01.PrintRune('\n')
		}
	}

}

//////////////////////////////////////////////////////////////// rostring.go

package main

import (
	"fmt"
	"os"
	"strings"
)

func deleteExtraSpaces(a []string) []string {
	var res []string
	for _, v := range a {
		if v != "" {
			res = append(res, v)
		}
	}
	return res
}

func main() {                
	if len(os.Args) == 2 {
		words := strings.Split(os.Args[1], " ")
		words = deleteExtraSpaces(words)
		if len(words) >= 1 {
			for _, v := range words[1:] {
				fmt.Print(v, " ")
			}
			fmt.Print(words[0])
		}
	}
	fmt.Println()
}

//////////////////////////////////////////////////////////////// revwstr.go	

package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {
	if len(os.Args) == 2 {
		a := strings.Split(os.Args[1], " ")
		for i := len(a) - 1; i >= 0; i-- {
			fmt.Print(a[i])
			if i != 0 {
				fmt.Print(" ")
			}
		}
		fmt.Println()
	}
}

//////////////////////////////////////////////////////////////// reverserange.go

package main

import (
	"fmt"
	"os"
	"strconv"
)

func main() {
	if len(os.Args) != 3 {
		return
	}
	a, err := strconv.Atoi(os.Args[1])
	if err != nil {
		fmt.Println(err)
		return
	}
	b, err := strconv.Atoi(os.Args[2])
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Print(b)
	for a != b {
		if b < a {
			b++
		} else {
			b--
		}
		fmt.Print(" ", b)
	}
	fmt.Println()
}

//////////////////////////////////////////////////////////////// range.go

package main

import (
	"fmt"
	"os"
	"strconv"
)

func main() {
	if len(os.Args) != 3 {
		return
	}
	a, err := strconv.Atoi(os.Args[1])
	if err != nil {
		fmt.Println(err)
		return
	}
	b, err := strconv.Atoi(os.Args[2])
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Print(a)
	for b != a {
		if a < b {
			a++
		} else {
			a--
		}
		fmt.Print(" ", a)
	}
	fmt.Println()
}

//////////////////////////////////////////////////////////////// slice.go

package piscine

func ifNegative(a []string, n int) int {
	if n < 0 {
		n = len(a) + n
	}

	if n < 0 {
		n = 0
	} else if n > len(a) {
		n = len(a)
	}

	return n
}

func Slice(a []string, nbr ...int) []string {
	if len(nbr) == 0 {
		return a
	}

	first := nbr[0]
	if len(nbr) == 1 {
		if first < 0 {
			first = len(a) + first
			if first < 0 {
				return a
			}
		}
		return a[first:]
	}
	second := nbr[1]

	first = ifNegative(a, first)
	second = ifNegative(a, second)

	if first > second {
		return nil
	}

	return a[first:second]
}

//////////////////////////////////////////////////////////////// itoa.go

package main

func Itoa(ival int) string {
	var buf []byte
	var r []byte
	var next int
	var right int

	for {
		if ival < 0 {
			ival = -1 * ival
			r = append(r, '-')
		}
		next = ival / 10
		right = ival - next*10
		ival = next
		buf = append(buf, byte('0'+right))
		if ival == 0 {
			break
		}
	}
	for j := 0; j < len(buf); j++ {
		r = append(r, buf[len(buf)-j-1])
	}
	return string(r)
}

//////////////////////////////////////////////////////////////// atoibase.go

package piscine

func ItoaBase(value, base int) string {
	origin := "0123456789ABCDEF"
	str := origin
	str = str[:base]
	runes := []rune(str)
	valid := true
	result := ""
	if base < 2 {
		valid = false
	}
	if !valid {
		return "NV"
	}

	if value == 0 {
		return "0"
	} else {
		if value < 0 {
			result = result + "-"
		}
		result += BaseRecursion(value, runes, base)
	}
	return result
}

func BaseRecursion(nbr int, runes []rune, base int) string {
	result := ""
	if nbr/base != 0 {
		result = BaseRecursion(nbr/base, runes, base)
	}
	mod := 0
	mod = nbr % base
	if mod < 0 {
		mod = -mod
	}
	result = result + string(runes[mod])

	return result
}

//////////////////////////////////////////////////////////////// foreach.go

package piscine

func ForEach(f func(int), a []int) {
	for _, el := range a {
		f(el)
	}
}

//////////////////////////////////////////////////////////////// fprime.go

package main

import (
	"fmt"
	"os"
	"strconv"
)

func fprime(value int) {
	if value == 1 {
		return
	}
	divisionIterator := 2
	for value > 1 {
		if value%divisionIterator == 0 {
			fmt.Print(divisionIterator)
			value = value / divisionIterator

			if value > 1 {
				fmt.Print("*")
			}
			divisionIterator--
		}
		divisionIterator++
	}
	fmt.Println()
}

func main() {
	if len(os.Args) == 2 {
		if i, err := strconv.Atoi(os.Args[1]); err == nil {
			fprime(i)
		}
	}
}

//////////////////////////////////////////////////////////////// printrevcomb.go

package main

import "github.com/01-edu/z01"

func main() {
	for i := '9'; i >= '0'; i-- {
		for j := i - 1; j >= '0'; j-- {
			for k := j - 1; k >= '0'; k-- {
				z01.PrintRune(i)
				z01.PrintRune(j)
				z01.PrintRune(k)
				if i != '2' || j != '1' || k != '0' {
					z01.PrintRune(',')
					z01.PrintRune(' ')
				}
			}
		}
	}
	z01.PrintRune('\n')
}

//////////////////////////////////////////////////////////////// listsize.go

package piscine

func ListSize(l *List) int {
	size := 0

	for l.Head != nil {
		size++
		l.Head = l.Head.Next
	}

	return size
}

//////////////////////////////////////////////////////////////// rpncalc.go

package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

func deleteExtraSpaces(a []string) (res []string) {
	for _, v := range a {
		if v != "" {
			res = append(res, v)
		}
	}
	return
}

func main() {
	if len(os.Args) != 2 {
		fmt.Println("Error")
		return
	}
	var values []int
	op := strings.Split(os.Args[1], " ")
	op = deleteExtraSpaces(op)
	for _, v := range op {
		val, err := strconv.Atoi(v)

		if err == nil {
			values = append(values, val)
			continue
		}

		n := len(values)
		if n < 2 {
			fmt.Println("Error")
			return
		}
            
		switch v {
		case "+":
			values[n-2] += values[n-1]
			values = values[:n-1]
		case "-":
			values[n-2] -= values[n-1]
			values = values[:n-1]
		case "*":
			values[n-2] *= values[n-1]
			values = values[:n-1]
		case "/":
			values[n-2] /= values[n-1]
			values = values[:n-1]
		case "%":
			values[n-2] %= values[n-1]
			values = values[:n-1]
		default:
			fmt.Println("Error")
			return
		}
	}
	if len(values) == 1 {
		fmt.Println(values[0])
	} else {
		fmt.Println("Error")
	}
}

//////////////////////////////////////////////////////////////// brackets.go	

package main

import (
	"fmt"
	"os"
)

func matchBrackets(exp string) bool {
	runes := []rune(exp)
	var opened []rune
	ptr := -1
	for _, c := range runes {
		if c == '(' || c == '[' || c == '{' {
			opened = append(opened, c)
			ptr++
		} else if c == ')' {
			if ptr < 0 || opened[ptr] != '(' {
				return false
			}
			opened = opened[:len(opened)-1]
			ptr--
		} else if c == ']' {
			if ptr < 0 || opened[ptr] != '[' {
				return false
			}
			opened = opened[:len(opened)-1]
			ptr--
		} else if c == '}' {
			if ptr < 0 || opened[ptr] != '{' {
				return false
			}
			opened = opened[:len(opened)-1]
			ptr--
		}
	}
	return len(opened) == 0
}

func main() {
	if len(os.Args) == 1 {
		fmt.Println()
	} else {
		for _, v := range os.Args[1:] {
			if matchBrackets(v) {
				fmt.Println("OK")
			} else {
				fmt.Println("Error")
			}
		}
	}
}

//////////////////////////////////////////////////////////////// options.go	

package main

import (
	"fmt"
	"os"
	"unicode"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("options: abcdefghijklmnopqrstuvwxyz")
		return
	}

	var options [32]bool
	for _, v := range os.Args {
		if len(v) < 2 {
			fmt.Println("Invalid Option")
			return
		}
		if v[0] == '-' {
			if v[1] == 'h' {
				fmt.Println("options: abcdefghijklmnopqrstuvwxyz")     
				return
			}
			// fill options
			for _, r := range v[1:] {
				if !unicode.Is(unicode.Latin, r) {
					fmt.Println("Invalid Option")
					return
				}
				options['z'-r+6] = true
			}
		}
	}
	for i, v := range options {
		if i%8 == 0 && i != 0 {
			fmt.Print(" ")
		}
		if v {
			fmt.Print(1)
		} else {
			fmt.Print(0)
		}
	}
	fmt.Println()
}

//////////////////////////////////////////////////////////////// grouping.go

package main

import (
	"fmt"
	"os"
	"strings"
	"unicode"
)

func singleSearch(exp []string, text string) []string {
	items := strings.Split(text, " ")
	var result []string

	for _, item := range items {
		for _, word := range exp {
			if strings.Contains(item, word) {
				result = append(result, item)
			}
		}
	}
	return result
}

func simpleSearch(runes []rune, text string) []string { 
	exp := string(runes)

	var result []string
	if !strings.ContainsRune(exp, '|') {
		helper := []string{exp}
		result = append(singleSearch(helper, text))
	} else {
		expWords := strings.Split(exp, "|")
		result = append(result, singleSearch(expWords, text)...)
	}
	return result
}

func brackets(regexp, text string) {
	if text == "" || regexp == "" {
		return
	}
	runes := []rune(regexp)

	if runes[0] == '(' && runes[len(runes)-1] == ')' {
		runes = runes[1 : len(runes)-1]
		result := simpleSearch(runes, text)
		for i, s := range result {
			if !unicode.IsLetter(rune(s[len(s)-1])) {
				s = s[0 : len(s)-1]
			}
			fmt.Printf("%d: %s\n", i+1, s)
		}
	}
}

func main() {
	if len(os.Args) == 3 {
		brackets(os.Args[1], os.Args[2])
	}
}

//////////////////////////////////////////////////////////////// printmemory.go

package piscine

import (
	"fmt"
	"strings"
)

func PrintMemory(a [10]byte) {
	str := ""
	for i, nbr := range a {
		fmt.Printf("%.2x", nbr)

		if ((i+1)%4 == 0 && i != 0) || i == len(a)-1 {
			fmt.Println()
		} else {
			fmt.Print(" ")
		}

		if nbr >= 33 && nbr <= 126 {
			str += string(rune(nbr))
		} else {
			str += "."
		}
	}
	fmt.Println(str + strings.Repeat(".", 10-len(a)))
}

//////////////////////////////////////////////////////////////// listremoveif.go

package piscine

func ListRemoveIf(l *List, data_ref interface{}) {
	temp := l.Head
	prev := l.Head

	for temp != nil && temp.Data == data_ref {
		l.Head = temp.Next
		temp = l.Head
	}
	for temp != nil {
		if temp.Data != data_ref {
			prev = temp
		}
		prev.Next = temp.Next
		temp = prev.Next
	}
}

//////////////////////////////////////////////////////////////// itoabase.go

package piscine

func ItoaBase(value, base int) string {
	origin := "0123456789ABCDEF"
	str := origin
	str = str[:base]
	runes := []rune(str)
	valid := true
	result := ""
	if base < 2 {
		valid = false
	}
	if !valid {
		return "NV"
	}

	if value == 0 {
		return "0"
	} else {
		if value < 0 {
			result = result + "-"
		}
		result += BaseRecursion(value, runes, base)
	}
	return result
}

func BaseRecursion(nbr int, runes []rune, base int) string {
	result := ""
	if nbr/base != 0 {
		result = BaseRecursion(nbr/base, runes, base)
	}
	mod := 0
	mod = nbr % base
	if mod < 0 {
		mod = -mod
	}
	result = result + string(runes[mod])

	return result
}

//////////////////////////////////////////////////////////////// brainfuck.go

package main

import (
	"os"

	"github.com/01-edu/z01"
)

func main() {
	ar := os.Args
	if len(ar) == 2 {
		Brainfuck(ar[1])
	} else {
		printer("\n")
	}
}

func Brainfuck(s string) {
	b := [2048]byte{}
	x := 0
	p := &b[x]
	depth := 0
	for i := 0; i < len(s); i++ {
		c := s[i]
		switch c {
		case '>':
			x++
		case '<':
			x--
		case '-':
			*p--
		case '+':
			*p++
		case '.':
			printer(string(*p))
		case '[':
			depth++
			if *p == 0 {
				oldDepth := depth - 1
				for oldDepth != depth {
					i++
					if s[i] == '[' {
						depth++
					} else if s[i] == ']' {
						depth--
					}
				}
			}
		case ']':
			depth--
			if *p != 0 {
				oldDepth := depth + 1
				for oldDepth != depth {
					i--
					if s[i] == '[' {
						depth++
					} else if s[i] == ']' {
						depth--
					}
				}
			}
		}
		p = &b[x]
	}
}

func printer(s string) {
	for _, r := range s {
		z01.PrintRune(r)
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////